int is_prime(int n)
{
    if (n == 2 || n == 3 || n == 5)
        return 1;
    if (n % 2 == 0) return 0;
    else if (n % 3 == 0) return 0;
    else if (n % 5 == 0) return 0;

    for (int i = 6; i <= n / 5; i++)
        if (n % i == 0) return 0;
    return 1;
}
/******
입력 = n  -->n이 소수인가?
1~n까지 전부나눠봄 1과n으로만 나눠지면 -->소수
결국 시간복잡도 = O(n)

최적화방법
1~n 까지 소수들로만 나누기 n번 -->n이하 소수개수  만큼 연산량 줄일수있음

2로나눈다면? 1~n/2 만 서칭
3으로 나눈다면 1~n/3만 서칭 이부분을 구현
루트n으로 나눈다면 1~n/루트n만서칭 == 1~루트n 어 같아지는 지점?!
즉 1부터 루트n까지만 서칭하면됨 == 시간복잡도=루트n

********/
